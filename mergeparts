#!/bin/sh
set -eu

usage() {
  cat <<'EOF'
mergeparts - concatenate chunk files (*.part) into a single output file.

Works with POSIX sh + busybox/coreutils.
Assumes chunk filenames are zero-padded so lexicographic order is correct.

Usage:
  mergeparts -o OUTPUT [--delete] [--pattern GLOB]

Options:
  -o OUTPUT        Output filename (required)
  --delete         Delete each .part after it is appended (saves disk space)
  --pattern GLOB   Which parts to merge (default: "*.part")

Examples:
  mergeparts -o file.rar --pattern 'Autonomos202408.rar.*.part'
  mergeparts -o file.rar --delete --pattern 'Autonomos202408.rar.*.part'
EOF
}

OUT=""
PAT="*.part"
DELETE=0

while [ $# -gt 0 ]; do
  case "$1" in
    -o) OUT="$2"; shift 2;;
    --pattern) PAT="$2"; shift 2;;
    --delete) DELETE=1; shift 1;;
    -h|--help) usage; exit 0;;
    *) echo "error: unknown arg: $1" >&2; usage; exit 1;;
  esac
done

[ -n "$OUT" ] || { echo "error: -o OUTPUT is required" >&2; exit 1; }

TMP="${OUT}.assembling"

# Find matching parts safely (no shell glob dependence)
# Print only basenames in current dir, then sort.
# NOTE: relies on zero-padded indexes so lexicographic sort is correct.
PARTS_LIST=$(find . -maxdepth 1 -name "$PAT" -print | sed 's|^\./||' | LC_ALL=C sort)

[ -n "$PARTS_LIST" ] || { echo "error: no parts match pattern: $PAT" >&2; exit 1; }

: > "$TMP"

echo "$PARTS_LIST" | while IFS= read -r f; do
  [ -f "$f" ] || { echo "error: missing part: $f" >&2; exit 1; }
  cat "$f" >> "$TMP" || { echo "error: failed appending: $f" >&2; exit 1; }
  if [ "$DELETE" -eq 1 ]; then
    rm -f "$f" || { echo "error: failed deleting: $f" >&2; exit 1; }
  fi
done

mv -f "$TMP" "$OUT"
echo "ok: wrote $OUT"
